#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VADER 7.0 UNIVERSAL INSTALLER ENHANCED

Instalador universal multiplataforma para Vader 7.0 que configura:
- Todos los runtimes Enhanced y originales
- CLI Universal
- Dependencias y herramientas necesarias
- Configuraci√≥n de entorno
- Validaci√≥n de instalaci√≥n

Soporta: Windows, macOS, Linux
Autor: Vader Universal Runtime Team
Versi√≥n: 7.0.0 Universal Installer Enhanced
Fecha: Julio 2025
"""

import sys
import os
import platform
import subprocess
import json
import shutil
import urllib.request
import zipfile
import tarfile
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import tempfile

# Configuraci√≥n del instalador
VADER_VERSION = "7.0.0"
INSTALLER_VERSION = "1.0.0"
VADER_REPO_URL = "https://github.com/LangVader/core"
VADER_SLOGAN = "LA PROGRAMACI√ìN UNIVERSAL: Libre, Descentralizada, Accesible"

class VaderUniversalInstaller:
    """Instalador Universal para Vader 7.0 Enhanced"""
    
    def __init__(self):
        self.version = VADER_VERSION
        self.installer_version = INSTALLER_VERSION
        self.slogan = VADER_SLOGAN
        self.system = platform.system().lower()
        self.architecture = platform.machine().lower()
        
        # Directorios de instalaci√≥n
        if self.system == "windows":
            self.install_dir = Path.home() / "AppData" / "Local" / "Vader"
            self.bin_dir = self.install_dir / "bin"
            self.config_dir = Path.home() / "AppData" / "Roaming" / "Vader"
        elif self.system == "darwin":  # macOS
            self.install_dir = Path.home() / ".vader"
            self.bin_dir = Path("/usr/local/bin")
            self.config_dir = Path.home() / ".config" / "vader"
        else:  # Linux
            self.install_dir = Path.home() / ".vader"
            self.bin_dir = Path.home() / ".local" / "bin"
            self.config_dir = Path.home() / ".config" / "vader"
        
        # Componentes a instalar
        self.components = {
            'core': {
                'name': 'Vader Core Runtime',
                'files': ['src/vader.py'],
                'required': True
            },
            'cli': {
                'name': 'CLI Universal Enhanced',
                'files': ['vader-cli-universal.py'],
                'required': True
            },
            'runtimes_enhanced': {
                'name': 'Runtimes Enhanced (Auditados)',
                'files': [
                    'vader-7.0-universal-python-enhanced.py',
                    'vader-7.0-universal-js-enhanced.js',
                    'vader-7.0-universal-iot-enhanced.py',
                    'vader-7.0-universal-cloud-enhanced.py'
                ],
                'required': True
            },
            'runtimes_original': {
                'name': 'Runtimes Originales',
                'files': [
                    'vader-7.0-universal-ai.py',
                    'vader-7.0-universal-mobile.py',
                    'vader-7.0-universal-gaming.py',
                    'vader-7.0-universal-blockchain.py',
                    'vader-7.0-universal-desktop.py',
                    'vader-7.0-universal-database.py',
                    'vader-7.0-universal-creative.py',
                    'vader-7.0-universal-robotics.py',
                    'vader-7.0-universal-datascience.py',
                    'vader-7.0-universal-edge.py'
                ],
                'required': False
            },
            'examples': {
                'name': 'Ejemplos y Demos',
                'files': [
                    'test_simple.vdr',
                    'demo_vader_7.0.vdr',
                    'test_ai_nativo.vdr',
                    'test_iot_nativo.vdr',
                    'test_cloud_nativo.vdr'
                ],
                'required': False
            },
            'documentation': {
                'name': 'Documentaci√≥n',
                'files': [
                    'README.md',
                    'INSTALACION.md',
                    'AUDITORIA_RUNTIMES_ENHANCED.md'
                ],
                'required': False
            }
        }
        
        # Dependencias por sistema
        self.dependencies = {
            'python': {
                'command': 'python3',
                'version_check': ['--version'],
                'min_version': '3.8',
                'install_instructions': {
                    'windows': 'Descargar desde https://python.org',
                    'darwin': 'brew install python3',
                    'linux': 'sudo apt-get install python3 python3-pip'
                }
            },
            'node': {
                'command': 'node',
                'version_check': ['--version'],
                'min_version': '14.0',
                'install_instructions': {
                    'windows': 'Descargar desde https://nodejs.org',
                    'darwin': 'brew install node',
                    'linux': 'sudo apt-get install nodejs npm'
                }
            },
            'git': {
                'command': 'git',
                'version_check': ['--version'],
                'min_version': '2.0',
                'install_instructions': {
                    'windows': 'Descargar desde https://git-scm.com',
                    'darwin': 'brew install git',
                    'linux': 'sudo apt-get install git'
                }
            }
        }
        
        print(f"üöÄ VADER {self.version} - Instalador Universal Enhanced v{self.installer_version}")
        print(f"‚ö° {self.slogan}")
        print(f"üíª Sistema: {platform.system()} {platform.release()} ({self.architecture})")
        print()
    
    def check_system_requirements(self) -> Tuple[bool, List[str]]:
        """Verifica los requisitos del sistema"""
        print("üîç Verificando requisitos del sistema...")
        
        issues = []
        
        # Verificar Python
        if not self.check_dependency('python'):
            issues.append("Python 3.8+ no encontrado")
        
        # Verificar Node.js (opcional pero recomendado)
        if not self.check_dependency('node'):
            print("‚ö†Ô∏è Node.js no encontrado (opcional para runtimes JS)")
        
        # Verificar Git (opcional)
        if not self.check_dependency('git'):
            print("‚ö†Ô∏è Git no encontrado (opcional para actualizaciones)")
        
        # Verificar permisos de escritura
        if not self.check_write_permissions():
            issues.append("Sin permisos de escritura en directorio de instalaci√≥n")
        
        # Verificar espacio en disco
        if not self.check_disk_space():
            issues.append("Espacio insuficiente en disco (m√≠nimo 100MB)")
        
        success = len(issues) == 0
        
        if success:
            print("‚úÖ Todos los requisitos cumplidos")
        else:
            print("‚ùå Algunos requisitos no se cumplen:")
            for issue in issues:
                print(f"   ‚Ä¢ {issue}")
        
        return success, issues
    
    def check_dependency(self, dep_name: str) -> bool:
        """Verifica si una dependencia est√° instalada"""
        dep_info = self.dependencies.get(dep_name)
        if not dep_info:
            return False
        
        try:
            result = subprocess.run(
                [dep_info['command']] + dep_info['version_check'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                print(f"‚úÖ {dep_name}: {result.stdout.strip()}")
                return True
            else:
                print(f"‚ùå {dep_name}: No encontrado")
                return False
                
        except (subprocess.TimeoutExpired, FileNotFoundError):
            print(f"‚ùå {dep_name}: No encontrado")
            return False
    
    def check_write_permissions(self) -> bool:
        """Verifica permisos de escritura"""
        try:
            self.install_dir.mkdir(parents=True, exist_ok=True)
            test_file = self.install_dir / "test_write.tmp"
            test_file.write_text("test")
            test_file.unlink()
            return True
        except (PermissionError, OSError):
            return False
    
    def check_disk_space(self) -> bool:
        """Verifica espacio disponible en disco"""
        try:
            if self.system == "windows":
                import ctypes
                free_bytes = ctypes.c_ulonglong(0)
                ctypes.windll.kernel32.GetDiskFreeSpaceExW(
                    ctypes.c_wchar_p(str(self.install_dir.parent)),
                    ctypes.pointer(free_bytes),
                    None,
                    None
                )
                free_space = free_bytes.value
            else:
                stat = os.statvfs(self.install_dir.parent)
                free_space = stat.f_bavail * stat.f_frsize
            
            # Requerir al menos 100MB
            return free_space > 100 * 1024 * 1024
            
        except Exception:
            return True  # Asumir que hay espacio si no se puede verificar
    
    def create_directories(self):
        """Crea los directorios necesarios"""
        print("üìÅ Creando directorios de instalaci√≥n...")
        
        directories = [
            self.install_dir,
            self.install_dir / "runtimes",
            self.install_dir / "examples",
            self.install_dir / "docs",
            self.config_dir,
            self.bin_dir
        ]
        
        for directory in directories:
            try:
                directory.mkdir(parents=True, exist_ok=True)
                print(f"‚úÖ {directory}")
            except PermissionError:
                print(f"‚ùå Sin permisos para crear: {directory}")
                if directory == self.bin_dir and self.system != "windows":
                    print("üí° Intenta ejecutar con sudo o usa un directorio local")
                raise
    
    def install_component(self, component_name: str, component_info: Dict) -> bool:
        """Instala un componente espec√≠fico"""
        print(f"üì¶ Instalando {component_info['name']}...")
        
        success = True
        for file_name in component_info['files']:
            source_path = Path(file_name)
            
            if not source_path.exists():
                print(f"‚ö†Ô∏è Archivo no encontrado: {file_name}")
                if component_info['required']:
                    success = False
                continue
            
            # Determinar directorio de destino
            if component_name == 'runtimes_enhanced' or component_name == 'runtimes_original':
                dest_dir = self.install_dir / "runtimes"
            elif component_name == 'examples':
                dest_dir = self.install_dir / "examples"
            elif component_name == 'documentation':
                dest_dir = self.install_dir / "docs"
            else:
                dest_dir = self.install_dir
            
            dest_path = dest_dir / source_path.name
            
            try:
                shutil.copy2(source_path, dest_path)
                
                # Hacer ejecutables los scripts
                if dest_path.suffix in ['.py', '.js', '.sh']:
                    dest_path.chmod(0o755)
                
                print(f"‚úÖ {source_path.name} ‚Üí {dest_path}")
                
            except Exception as e:
                print(f"‚ùå Error copiando {file_name}: {str(e)}")
                success = False
        
        return success
    
    def create_cli_wrapper(self):
        """Crea el wrapper del CLI para acceso global"""
        print("üîß Configurando CLI global...")
        
        cli_source = self.install_dir / "vader-cli-universal.py"
        
        if self.system == "windows":
            # Crear archivo .bat para Windows
            wrapper_path = self.bin_dir / "vader.bat"
            wrapper_content = f'''@echo off
python "{cli_source}" %*
'''
        else:
            # Crear script shell para Unix
            wrapper_path = self.bin_dir / "vader"
            wrapper_content = f'''#!/bin/bash
python3 "{cli_source}" "$@"
'''
        
        try:
            wrapper_path.write_text(wrapper_content)
            wrapper_path.chmod(0o755)
            print(f"‚úÖ CLI wrapper creado: {wrapper_path}")
            
            # Verificar que el directorio bin est√© en PATH
            self.check_path_configuration()
            
        except Exception as e:
            print(f"‚ùå Error creando CLI wrapper: {str(e)}")
    
    def check_path_configuration(self):
        """Verifica y sugiere configuraci√≥n de PATH"""
        path_env = os.environ.get('PATH', '')
        bin_dir_str = str(self.bin_dir)
        
        if bin_dir_str not in path_env:
            print("‚ö†Ô∏è El directorio bin no est√° en PATH")
            print("üí° Para usar 'vader' globalmente, agrega esto a tu shell:")
            
            if self.system == "windows":
                print(f"   set PATH=%PATH%;{bin_dir_str}")
                print("   O config√∫ralo permanentemente en Variables de Entorno")
            else:
                shell_config = "~/.bashrc" if Path.home().joinpath(".bashrc").exists() else "~/.zshrc"
                print(f"   echo 'export PATH=\"{bin_dir_str}:$PATH\"' >> {shell_config}")
                print(f"   source {shell_config}")
    
    def install_python_dependencies(self):
        """Instala dependencias de Python"""
        print("üêç Instalando dependencias de Python...")
        
        # Crear requirements.txt con todas las dependencias
        requirements = [
            "requests>=2.28.0",
            "aiohttp>=3.8.0",
            "websockets>=10.0",
            "pyyaml>=6.0",
            "click>=8.0.0",
            "rich>=12.0.0",
            "psutil>=5.9.0"
        ]
        
        requirements_path = self.install_dir / "requirements.txt"
        requirements_path.write_text('\n'.join(requirements))
        
        try:
            subprocess.run([
                "python3", "-m", "pip", "install", "-r", str(requirements_path)
            ], check=True, capture_output=True)
            print("‚úÖ Dependencias de Python instaladas")
        except subprocess.CalledProcessError as e:
            print("‚ö†Ô∏è Algunas dependencias de Python no se pudieron instalar")
            print("üí° Puedes instalarlas manualmente con:")
            print(f"   pip install -r {requirements_path}")
    
    def create_config_file(self):
        """Crea archivo de configuraci√≥n"""
        print("‚öôÔ∏è Creando configuraci√≥n...")
        
        config = {
            "version": self.version,
            "install_date": str(Path().cwd()),
            "install_dir": str(self.install_dir),
            "system": self.system,
            "architecture": self.architecture,
            "components_installed": list(self.components.keys()),
            "default_runtime": "python",
            "auto_detect": True,
            "verbose": False
        }
        
        config_file = self.config_dir / "config.json"
        config_file.write_text(json.dumps(config, indent=2))
        print(f"‚úÖ Configuraci√≥n guardada: {config_file}")
    
    def validate_installation(self) -> bool:
        """Valida que la instalaci√≥n sea correcta"""
        print("üîç Validando instalaci√≥n...")
        
        # Verificar archivos principales
        essential_files = [
            self.install_dir / "vader-cli-universal.py",
            self.install_dir / "runtimes" / "vader-7.0-universal-python-enhanced.py"
        ]
        
        for file_path in essential_files:
            if not file_path.exists():
                print(f"‚ùå Archivo esencial faltante: {file_path}")
                return False
        
        # Probar CLI
        try:
            cli_path = self.install_dir / "vader-cli-universal.py"
            result = subprocess.run([
                "python3", str(cli_path), "--version"
            ], capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                print("‚úÖ CLI funcional")
            else:
                print("‚ùå CLI no funciona correctamente")
                return False
                
        except Exception as e:
            print(f"‚ùå Error probando CLI: {str(e)}")
            return False
        
        print("‚úÖ Instalaci√≥n validada correctamente")
        return True
    
    def show_installation_summary(self):
        """Muestra resumen de la instalaci√≥n"""
        print("\n" + "="*60)
        print("üéâ ¬°INSTALACI√ìN COMPLETADA EXITOSAMENTE!")
        print("="*60)
        print(f"üöÄ VADER {self.version} - Universal Runtime Enhanced")
        print(f"‚ö° {self.slogan}")
        print()
        print("üìç UBICACIONES:")
        print(f"   Instalaci√≥n: {self.install_dir}")
        print(f"   Configuraci√≥n: {self.config_dir}")
        print(f"   CLI: {self.bin_dir / 'vader'}")
        print()
        print("üõ†Ô∏è COMPONENTES INSTALADOS:")
        for comp_name, comp_info in self.components.items():
            print(f"   ‚úÖ {comp_info['name']}")
        print()
        print("üöÄ PRIMEROS PASOS:")
        print("   1. Reinicia tu terminal")
        print("   2. Ejecuta: vader --help")
        print("   3. Prueba: vader test_simple.vdr")
        print()
        print("üìö DOCUMENTACI√ìN:")
        print(f"   {self.install_dir / 'docs' / 'README.md'}")
        print(f"   {VADER_REPO_URL}")
        print()
        print("üéØ ¬°Vader est√° listo para la programaci√≥n universal!")
        print("="*60)
    
    def install(self, components_to_install: Optional[List[str]] = None) -> bool:
        """Ejecuta la instalaci√≥n completa"""
        try:
            print("üöÄ Iniciando instalaci√≥n de Vader 7.0 Universal Runtime...")
            print()
            
            # 1. Verificar requisitos
            requirements_ok, issues = self.check_system_requirements()
            if not requirements_ok:
                print("‚ùå No se pueden cumplir los requisitos m√≠nimos")
                return False
            
            # 2. Crear directorios
            self.create_directories()
            
            # 3. Instalar componentes
            components_to_install = components_to_install or list(self.components.keys())
            
            for comp_name in components_to_install:
                if comp_name in self.components:
                    success = self.install_component(comp_name, self.components[comp_name])
                    if not success and self.components[comp_name]['required']:
                        print(f"‚ùå Error instalando componente requerido: {comp_name}")
                        return False
            
            # 4. Configurar CLI
            self.create_cli_wrapper()
            
            # 5. Instalar dependencias
            self.install_python_dependencies()
            
            # 6. Crear configuraci√≥n
            self.create_config_file()
            
            # 7. Validar instalaci√≥n
            if not self.validate_installation():
                print("‚ùå La validaci√≥n de instalaci√≥n fall√≥")
                return False
            
            # 8. Mostrar resumen
            self.show_installation_summary()
            
            return True
            
        except KeyboardInterrupt:
            print("\nüõë Instalaci√≥n interrumpida por el usuario")
            return False
        except Exception as e:
            print(f"\nüí• Error durante la instalaci√≥n: {str(e)}")
            return False

def main():
    """Funci√≥n principal del instalador"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Instalador Universal para Vader 7.0",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Ejemplos:
  python install-vader-universal.py                    # Instalaci√≥n completa
  python install-vader-universal.py --components core cli  # Solo componentes espec√≠ficos
  python install-vader-universal.py --help            # Mostrar ayuda
        """
    )
    
    parser.add_argument(
        '--components',
        nargs='+',
        choices=['core', 'cli', 'runtimes_enhanced', 'runtimes_original', 'examples', 'documentation'],
        help='Componentes espec√≠ficos a instalar'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version=f'Vader Universal Installer {INSTALLER_VERSION}'
    )
    
    args = parser.parse_args()
    
    try:
        installer = VaderUniversalInstaller()
        success = installer.install(args.components)
        return 0 if success else 1
        
    except KeyboardInterrupt:
        print("\nüõë Instalaci√≥n cancelada")
        return 130
    except Exception as e:
        print(f"üí• Error fatal: {str(e)}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
